# Introduction To Tool Generation

This reference manual describes how to generate tools that deal with
language processing.

These tools are partially generated by the *MontiCore* and partially
need handcoded extensions. This reference manual explains how to do this
efficiently.

We assume that the reader is familiar with a variety of computer science
concepts, such as *grammars*, `UML` and in particular their `class diagrams` and Java.
If not, [[HMU06]](#HMU06) is suggested for grammars, [[Rum16]](#Rum16) for UML, and
[[GJS05]](#GJS05) for Java.

As we will further explain, MontiCore is a meta-tool, actually a language workbench: It generates
tools. It may well be that the generated tooling is itself a generator.
That is fine, but in order to avoid confusion, we should be clear that
there are two levels. Furthermore, the generated tooling can not only be
a generator, but can be used for transformation, simple and complex
analysis, simulation or the connection of runtime data with the
originating models.

All the tooling is about *processing models* in standard or *domain
specific languages* (DLSs). MontiCore generates infrastructure, such that
many models as well as heterogeneous models, that means of different
languages, can be processed. *Modeling in the large* is well assisted.

MontiCore is not only about generation of tools, but in particular about *reuse*
of tool components that have been developed independently. In particular
MontiCore provides a number of techniques to systematically reuse
*language components* by *composing*, *extending* or *inheriting* them.
MontiCore assists an easy development and extension of languages and
thus should be a good solution for tool development.

<div class="tip">
<div class="tip-header">
<img src="/docs/img/small_bulb.png" width="20">
Tip 1.1 Where to find MontiCore
</div>
The MontiCore language workbench as well as a number of language
components are available as open source. More interesting information
can be found at:
```
www.monticore.de                           // Newest info about
                                           // MontiCore and the
                                           // MontiCore generator
https:/(*@@*)/github.com/MontiCore         // Sources of the core
                                           // project on GitHub
http:/(*@@*)/monticore.github.io/monticore // Github page of the
                                           // MontiCore project
```
</div>

MontiCore also includes a number of plug-ins e.g. for Eclipse or
EMF-compatible generation and thus supposedly has a rather useful
development environment. We strongly encourage the reader to download
and install MontiCore.

## MontiCore Language Workbench

The MontiCore language workbench can be used both as a closed product out-of-the-box for the
generation of software as well as an open, customizable framework for
tool development. MontiCore itself is a generator with the speciality
that the products it produces are generators themselves. As already
said, MontiCore is therefore a meta-tool.

At a glimpse, the features of MontiCore are:

- Modular definition of languages and language components
- Explicit interfaces between models, allowing heterogeneous composition of models.
- Techniques for composition of languages, thus allowing:
    - independent language development,
    - language extension,
    - language inheritance including concept replacement, and
    - composition of language tools.
- Assistance for model analysis.
- Assistance for model transformation by reusing the concrete syntax of the modeling language.
- Only a single source is necessary for the definition of concrete syntax abstract syntax, parser and internal representation of models.
- Easy definition of e.g. Eclipse language specific editors.
- Explicit management of variability in both, languages and their generation tools.

Numerous tools for domain specific modeling languages as well as general
purpose languages have been developed by using MontiCore. Among them are
MontiCore itself, a larger part of the UML set of languages, the
architectural description language MontiArc, Java, a subset of Ansi-C++ and a feature diagram DSL 
(see e.g. Figure 1.2. Various applications in engineering domains
(AutoSar, autonomous driving simulation, flight control, building
facilities, energy management, cloud service configuration) and natural science (human
brain, control for physical experiments) demonstrate the usability of MontiCore.

![](img/MontiCore--Selected-Languages.png)

<figcaption>Figure 1.2: Some languages MontiCore provides</figcaption>

In addition to the above mentioned bullets this document also discusses:
- How a generator architecture looks like
- Out-of-the box use of MontiCore
- Language definition
- How an abstract syntax (AST) looks like
- Managing symbols and visibility of definitions
- Model composition
- Language components and their composition
- Navigation an manipulation of the AST with compositional visitors
- Generation using FreeMarker's templates
- Integration of handwritten code

There is more to say about MontiCore. However, this document explicitly
omits the internal architecture of MontiCore, how to define and apply
transformations in concrete syntax, how to manage variability of
languages, and various application languages, such as UML, MontiArc etc.
The MontiCore website provides additional information.

## Notational Conventions

Although MontiCore mainly relies on textual models, a diagrammatic
representation is sometimes convenient. To be clear to what language the
model, code snippet, etc. belongs to, it will be marked with a flag. An
example is shown in the upper right corner of
ListingÂ 1.3, which is an excerpt of a generated Java
class called `Person`.

``` java
class Person {
  private String firstname, surname;
  Adress adr;
}
```
<figcaption>Listing 1.3: Example in Java</figcaption>


We use various abbreviations, such as `CD` for class diagrams, etc.
Especially class diagrams serve multiple purposes, therefore, it is
necessary to understand precisely, what is modeled by a CD. In several
chapters we use the modeling language *Class diagrams for Analysis 
(abbreviated: `CD4A`) as source for the
generation process. But, we also use class diagrams to exhibit concrete
situations in the tool or product, such as for example the extension of
a generated class `GroupTOP` by handcoded class `Group`, which are both
present in the product which is the final target of the development
process. We show this like in Figure 1.4.

![](img/Notational-Conventions.png)
<figcaption>Figure 1.3: Notational conventions</figcaption>

## Textual Modeling

Many experts think that the mental model in the conscious human brain is
the most important form of models. Thus, it is not so important how to
represent the modeling information on the screen or on paper, but that
the model communicates the right information and concepts. However, for
easy understanding, quick adaptations, logical manipulations,
refactorings or similar purposes, it seems not so unimportant to use an
appropriate representation.

It is an ongoing debate, whether and where textual or graphical models
are better for software development. It also depends on the background
of the reader, which model is easier to be used. Both forms of models do
have advantages. Experts for example are quicker to produce the model in
text form, because they are not distracted by "pushing boxes around"
to produce nice diagrams. And for tool developers it is easier to write
a text processor than a diagram processing tool, especially when using
this reference manual.

Our experience is that computer scientists tend towards textual models
due to higher compactness, more efficient creation, refactoring and use
and less dealing with graphical layout.

Diagrams and text will coexist in the future and may be even closely
integrated. MontiCore currently focusses on text as the main form of
input and output. Thus, the infrastructure is easier for tool
development.

## Methodical Considerations: Agile Modeling

There are a variety of development processes, ranging from traditional
document oriented approaches, such as the V-Model, up to several incarnations
of agile development, such as Extreme Programming (XP) [[BA04]](#BA04) and Scrum [[SB01]](#SB01). 
It would go beyond
the scope of this reference manual to talk about methodological issues.
However, we would like to hint towards discussions that a development
job could well be assisted by models and high-level modeling languages,
if the generation process for code and tests is efficient and robust. In
[[Rum11,Rum12,Rum16]](#Rum11) this is discussed in detail.

[[Rum12]](#Rum12) for example suggests to combine the advantages of agile
development with use of models by concentrating on a set of
complementing models with as little redundancy as possible in order to
represent each piece of information only once and as compact as
possible. Figure 1.5 depicts this idea in an abstract form,
mainly focussing on the UML.

![](img/Agile-use-of-Models-for-Coding-and-Testing--Usage-of-UML-Diagrams.png)
<figcaption>Figure 1.5: Agile use of models for coding and testing</figcaption>

Some generators concentrate on the system while other generators derive
automatically running testing code similar to tests [[Bec04]](#Bec04). If the
software to be developed is part of a larger system, it would also be
possible to derive automatically running simulations for the complete
product or some of its components to check the correctness of the
system, e.g. done in [[BR12b]](#BR12b).

As a consequence, we suggest to base larger parts of the development
project on modeling artifacts. Models can be used for

-   rapid prototyping,
-   code generation,
-   generation of automated tests,
-   documentation,
-   static analysis, and
-   refactoring and evolution.

In a generative software development project, models serve as central
artifacts. They are used for programming, testing and specifying.

<div class="tip">
<div class="tip-header">
<img src="/docs/img/small_bulb.png" width="25">
Tip 1.6 Agile Model-Based Development
</div>
<div class="tip-line"></div>
<p>Agile software development and model-based generation fit together.</p>

<p>First and foremost, generation obviously increases the speed of
development. However, this only becomes an advantage, when two important
criteria are fulfilled:</p>

<ol>
  <li>It is important to easily <em>rerun the generator</em> each time a slight
change was made in the models. A one-shot generation is not helpful,
because it does not assist any form of evolution, but only the waterfall
model. So, it is best to not manually touch generated code.</li>
  <li>To keep the pace of development, generation must be <em>quick</em>. In
particular when generating lots of code from lots of models, incremental
generation based on detected changes is necessary. So, it is optimal to
use an intelligent dependency management that allows automatic
incremental and thus efficiently minimal re-generation.</li>
</ol>

<p>Then agile generative software development becomes possible.</p>
</div>

<div class="tip">
<div class="tip-header">
<img src="/docs/img/small_bulb.png" width="25">
Tip 1.7 Current Version of this Document is Online
</div>
<p>MontiCore is an evolving tool. Therefore, more material describing the
capabilities and forms of usage will evolve over time.</p>
<p>Therefore, you might also have a look at MontiCore's website.</p>
<p>However, your feedback will definitely be appreciated, e.g. by emails to
`monticore@se-rwth.de` or through sending a printout with comments.</p>
</div>

<table>
  <tr id="BA04">
    <td>[BA04]</td>
    <td>Kent Beck and Cynthia Andres.
        <em>Extreme Programming Explained: Embrace Change.</em> 
        Addison-Wesley Professional, 2004.</td>
  </tr>
  <tr id="Bec15">
    <td>[Bec15]</td>
    <td>Kent Beck.
        <em>JUnit Pocket Guide.</em> 
        O'Reilly, 2015.</td>
  </tr>
  <tr id="BR12b">
    <td>[BR12b]</td>
    <td>Christian Berger and Bernhard Rumpe.
        Engineering Autonomous Driving Software.
        In C. Rouff and M. Hinchey, editors,
        <em>Experience from the DARPA Urban Challenge</em>, 
        pages 243271. Springer, Germany, 2012.</td>
  </tr>
  <tr id="GJS05">
    <td>[GJS05]</td>
    <td>James Gosling, Bill Joy, and Guy L. Steele.
        <em>The Java Language Specification.</em> 
        Addison-Wesley, 3rd edition, 2005.</td>
  </tr>
  <tr id="HMU06">
    <td>[HMU06]</td>
    <td>John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman.
        <em>Introduction to Automata Theory, Languages, and Computation (3rd Edition).</em> 
        Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2006.</td>
  </tr>
  <tr id="Rum11">
    <td>[Rum11]</td>
    <td>Bernhard Rumpe.
        <em>Modellierung mit UML, 2te Auflage.</em> 
        Springer Berlin, September 2011.</td>
  </tr>
  <tr id="Rum12">
    <td>[Rum12]</td>
    <td>Bernhard Rumpe.
        <em>Agile Modellierung mit UML: Codegenerierung, TestfÃ¤lle, Refactoring, 2te Auflage.</em> 
        Springer Berlin, Juni 2012.</td>
  </tr>
  <tr id="Rum16">
    <td>[Rum16]</td>
    <td>Bernhard Rumpe.
        <em>Modeling with UML: Language, Concepts, Methods.</em> 
        Springer International, July 2016.</td>
  </tr>
  <tr id="SB01">
    <td>[SB01]</td>
    <td>Ken Schwaber and Mike Beedle.
        <em>Agile Software Development with Scrum.</em> 
        Prentice Hall PTR, Upper Saddle River, NJ, USA, 1st edition, 2001.</td>
  </tr>
</table>