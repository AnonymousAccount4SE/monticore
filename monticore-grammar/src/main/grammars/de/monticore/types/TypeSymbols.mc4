/* (c) https://github.com/MontiCore/monticore */
package de.monticore.types;

/**
 * This grammar is used to generate an abstract Syntax only.
 * These AST-classes are then used to store typing information
 * in the SymbolTable.
 *
 * The grammar introduces the symbols for
 * Types, Methods, Fields and TypeVariables
 * 
 * mainly to attach the Type-symbol to it:
 * It serves as abstract interface that allows various
 * forms of types to build the same kind of type symbol
 * (or subclasses thereof)
 *
 * This eases the reuse of type structures in languages similar to Java,
 * that are somewhat simplified, e.g. without generics.
 *
 * The grammar contains types from Java, e.g., primitives, void,
 * classes (also sometimes called "reference types").
 *
 * This grammar is part of a hierarchy of types, namely
 * * types/MCTypeSymbols.mc4
 * * types/MCBasicTypes.mc4
 * * types/MCCollectionTypes.mc4
 * * types/MCSimpleGenericTypes.mc4
 * * types/MCFullGenericTypes.mc4
 * also defining generics or arrays.
 *
*/

component grammar TypeSymbols extends de.monticore.MCBasics {

  /*=================================================================*/

  /** ASTType is the top level interface for all kinds of types
   * (except Void).
   * It mainly introduces the Type-Symbol.
   */
  interface scope symbol Type = Name ;

  /** Type symbols are extended by three elements:
  	methods and fields they contain
	and type parameters they may have   
	TODO: separate Types from TypeFunctions!
   */
  symbolrule Type =
    methods: de.monticore.types.typesymbols._symboltable.MethodSymbol*
    fields: de.monticore.types.typesymbols._symboltable.FieldSymbol*
    typeParameter: de.monticore.types.typesymbols._symboltable.TypeVarSymbol*
  ;
  TypeImpl implements Type = Name;

  /*=================================================================*/

  /** ASTTypeVar is the top level interface for all kinds of types
   * (except Void).
   * It mainly introduces the TypeVar-Symbol class
   */
  interface symbol TypeVar = Name;
  symbolrule TypeVar =
    upperBound: de.monticore.typescalculator.TypeExpression*
  ;
  TypeVarImpl implements TypeVar = Name;

  /*=================================================================*/

  interface symbol Field = Name ;
  symbolrule  Field =
    type: de.monticore.typescalculator.TypeExpression
  ;
  FieldImpl implements Field = Name;

  /*=================================================================*/

  interface scope symbol Method = Name;
  symbolrule Method =
    parameter: de.monticore.types.typesymbols._symboltable.FieldSymbol*
    returnType: de.monticore.typescalculator.TypeExpression
  ;
  MethodImpl implements Method = Name;


  /*=================================================================*/
  /*=================================================================*/

  /** Anbei eine kondensierung der Typ-Ausdrücke:
   * Annahme: diese Grammatik wurd benutzt um AST-Klassen zu erzeugen
   * und dort landen nur korrekte Typausdrücke.
   * (Es gibt keinen Parser dafür, keine CoCo's)
   * Dennoch sind nicht alle Konstellationen erlaubt.
   */
  
  interface SymTType;
  SymTVoidType implements SymTType = "void";

  SymTTypeVar implements SymTType = Name;

  SymTPrimitiveType implements SymTType = Name;

  SymTObjectType implements SymTType = Name;   // könnte auch MCQualifiedName sein ...

  SymTArrayType implements SymTType = dimensions:int SymTType;

  SymTBasicGenericType implements SymTType = SymTTypeConstructorAppl;

  SymTMultipleGenericType implements SymTType = SymTTypeConstructorAppl+; 


  // Das ist kein bzw. nicht nur ein voller Type
  SymTTypeConstructorAppl = constructor:Name SymTTypeArgument+; // Name kann wieder Qualified sein

  SymTTypeArgument = SymTType ["extends"]? ["super"]?


//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

  // Das kann man benutzen, um die ungebundenen TypVariablen ganz oben
  // zu fixieren (ist mir unklar, ob man das braucht, die funktionalen
  // Typchecker nutzen das alle: die halten halt nichts von freien variablen
  SymTParameterizedType implements SymTType = vars:Name SymTType


  // Und hier noch was für Typkonstruktoren (die ja KEINE Typen sind):
  // aber auch als Symbole abgelegt werden wollen:

  SymTSimpleTypeConstructor = Name arguments:int;

  SymTWildTypeConstructor = Name SymTTypeVariableDeclaration*;

  interface SymTTypeVariableDeclaration = Name;
  SymTTypeVariableDeclarationVar = Name;
  SymTTypeVariableDeclarationUpperBound = Name SymTType;
  SymTTypeVariableDeclarationAnd = Name;

  // Alternativer Ansatz zu oben:
  interface SymTTypeArgument = SymTType ;	// auch eine Art "? extends ..."
  SymTTypeArgumentType = SymTType 		// darzustellen; Vorzug:
  SymTTypeArgumentExtends = SymTType 	// wenn man weiss "? ext." wird nicht benutzt
  SymTTypeArgumentSuper = SymTType 	// lassen sich manche Klassen ignorieren
}
