/* generated by template symboltable.GlobalScopeInterface*/




package de.monticore.grammar.grammar._symboltable;

import com.google.common.collect.Lists;
import de.monticore.io.paths.ModelPath;
import de.monticore.symboltable.modifiers.AccessModifier;
import de.se_rwth.commons.logging.Log;

import java.util.Collection;
import java.util.Set;
import java.util.function.Predicate;

public interface IGrammarGlobalScope extends IGrammarScope {

  ModelPath getModelPath();

  GrammarLanguage getGrammarLanguage();

  void cache(GrammarModelLoader modelLoader, String calculatedModelName);

  boolean continueWithModelLoader(String calculatedModelName, GrammarModelLoader modelLoader);
  default boolean checkIfContinueAsSubScope(String symbolName) {
    return false;
  }

  default Collection<de.monticore.grammar.grammar._symboltable.MCGrammarSymbol> resolveMCGrammarMany(boolean foundSymbols,
                                                                                                     final String symbolName, final AccessModifier modifier, final Predicate<de.monticore.grammar.grammar._symboltable.MCGrammarSymbol> predicate) {

    // First, try to resolve the symbol in the current scope and its sub scopes.
    Collection<de.monticore.grammar.grammar._symboltable.MCGrammarSymbol> resolvedSymbol = resolveMCGrammarDownMany(foundSymbols, symbolName,  modifier, predicate);

    if (!resolvedSymbol.isEmpty()) {
      return resolvedSymbol;
    }

    // Symbol not found: try to load corresponding model and build its symbol table
    loadModelsForMCGrammar(symbolName);

    // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
    resolvedSymbol = resolveMCGrammarDownMany(false, symbolName, modifier, predicate);
    foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
    resolvedSymbol.addAll(resolveAdaptedMCGrammar(foundSymbols, symbolName, modifier, predicate));

    return resolvedSymbol;
  }

  default Collection<de.monticore.grammar.grammar._symboltable.MCGrammarSymbol> resolveAdaptedMCGrammar(boolean foundSymbols, String symbolName, AccessModifier modifier, Predicate<de.monticore.grammar.grammar._symboltable.MCGrammarSymbol> predicate){
    return Lists.newArrayList();
  }

  default void loadModelsForMCGrammar(String symbolName) {

    GrammarModelLoader modelLoader = getGrammarLanguage().getModelLoader();
    Set<String> calculatedModelNames = getGrammarLanguage().calculateModelNamesForMCGrammar(symbolName);

    for (String calculatedModelName : calculatedModelNames) {
      if (continueWithModelLoader(calculatedModelName, modelLoader)) {
        modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), this);
        cache(modelLoader, calculatedModelNames.iterator().next());
      } else {
        Log.debug("Already tried to load model for '" + symbolName + "'. If model exists, continue with cached version.", GrammarGlobalScope.class.getSimpleName());
      }


    }
  }
  default Collection<ProdSymbol> resolveProdMany(boolean foundSymbols,
                                                 final String symbolName, final AccessModifier modifier, final Predicate<ProdSymbol> predicate) {

    // First, try to resolve the symbol in the current scope and its sub scopes.
    Collection<ProdSymbol> resolvedSymbol = resolveProdDownMany(foundSymbols, symbolName,  modifier, predicate);

    if (!resolvedSymbol.isEmpty()) {
      return resolvedSymbol;
    }

    // Symbol not found: try to load corresponding model and build its symbol table
    loadModelsForProd(symbolName);

    // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
    resolvedSymbol = resolveProdDownMany(false, symbolName, modifier, predicate);
    foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
    resolvedSymbol.addAll(resolveAdaptedProd(foundSymbols, symbolName, modifier, predicate));

    return resolvedSymbol;
  }

  default Collection<ProdSymbol> resolveAdaptedProd(boolean foundSymbols, String symbolName, AccessModifier modifier, Predicate<ProdSymbol> predicate){
    return Lists.newArrayList();
  }

  default void loadModelsForProd(String symbolName) {

    GrammarModelLoader modelLoader = getGrammarLanguage().getModelLoader();
    Set<String> calculatedModelNames = getGrammarLanguage().calculateModelNamesForProd(symbolName);

    for (String calculatedModelName : calculatedModelNames) {
      if (continueWithModelLoader(calculatedModelName, modelLoader)) {
        modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), this);
        cache(modelLoader, calculatedModelNames.iterator().next());
      } else {
        Log.debug("Already tried to load model for '" + symbolName + "'. If model exists, continue with cached version.", GrammarGlobalScope.class.getSimpleName());
      }


    }
  }
  default Collection<de.monticore.types.mcbasictypes._symboltable.MCTypeSymbol> resolveMCTypeMany(boolean foundSymbols,
                                                                                                  final String symbolName, final AccessModifier modifier, final Predicate<de.monticore.types.mcbasictypes._symboltable.MCTypeSymbol> predicate) {

    // First, try to resolve the symbol in the current scope and its sub scopes.
    Collection<de.monticore.types.mcbasictypes._symboltable.MCTypeSymbol> resolvedSymbol = resolveMCTypeDownMany(foundSymbols, symbolName,  modifier, predicate);

    if (!resolvedSymbol.isEmpty()) {
      return resolvedSymbol;
    }

    // Symbol not found: try to load corresponding model and build its symbol table
    loadModelsForMCType(symbolName);

    // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
    resolvedSymbol = resolveMCTypeDownMany(false, symbolName, modifier, predicate);
    foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
    resolvedSymbol.addAll(resolveAdaptedMCType(foundSymbols, symbolName, modifier, predicate));

    return resolvedSymbol;
  }

  default Collection<de.monticore.types.mcbasictypes._symboltable.MCTypeSymbol> resolveAdaptedMCType(boolean foundSymbols, String symbolName, AccessModifier modifier, Predicate<de.monticore.types.mcbasictypes._symboltable.MCTypeSymbol> predicate){
    return Lists.newArrayList();
  }

  default void loadModelsForMCType(String symbolName) {

    GrammarModelLoader modelLoader = getGrammarLanguage().getModelLoader();
    Set<String> calculatedModelNames = getGrammarLanguage().calculateModelNamesForMCType(symbolName);

    for (String calculatedModelName : calculatedModelNames) {
      if (continueWithModelLoader(calculatedModelName, modelLoader)) {
        modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), this);
        cache(modelLoader, calculatedModelNames.iterator().next());
      } else {
        Log.debug("Already tried to load model for '" + symbolName + "'. If model exists, continue with cached version.", GrammarGlobalScope.class.getSimpleName());
      }


    }
  }
  default Collection<AdditionalAttributeSymbol> resolveAdditionalAttributeMany(boolean foundSymbols,
                                                                               final String symbolName, final AccessModifier modifier, final Predicate<AdditionalAttributeSymbol> predicate) {

    // First, try to resolve the symbol in the current scope and its sub scopes.
    Collection<AdditionalAttributeSymbol> resolvedSymbol = resolveAdditionalAttributeDownMany(foundSymbols, symbolName,  modifier, predicate);

    if (!resolvedSymbol.isEmpty()) {
      return resolvedSymbol;
    }

    // Symbol not found: try to load corresponding model and build its symbol table
    loadModelsForAdditionalAttribute(symbolName);

    // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
    resolvedSymbol = resolveAdditionalAttributeDownMany(false, symbolName, modifier, predicate);
    foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
    resolvedSymbol.addAll(resolveAdaptedAdditionalAttribute(foundSymbols, symbolName, modifier, predicate));

    return resolvedSymbol;
  }

  default Collection<AdditionalAttributeSymbol> resolveAdaptedAdditionalAttribute(boolean foundSymbols, String symbolName, AccessModifier modifier, Predicate<AdditionalAttributeSymbol> predicate){
    return Lists.newArrayList();
  }

  default void loadModelsForAdditionalAttribute(String symbolName) {

    GrammarModelLoader modelLoader = getGrammarLanguage().getModelLoader();
    Set<String> calculatedModelNames = getGrammarLanguage().calculateModelNamesForAdditionalAttribute(symbolName);

    for (String calculatedModelName : calculatedModelNames) {
      if (continueWithModelLoader(calculatedModelName, modelLoader)) {
        modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), this);
        cache(modelLoader, calculatedModelNames.iterator().next());
      } else {
        Log.debug("Already tried to load model for '" + symbolName + "'. If model exists, continue with cached version.", GrammarGlobalScope.class.getSimpleName());
      }


    }
  }











}
