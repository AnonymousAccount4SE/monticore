/* generated by template symboltable.ModelLoader*/




package de.monticore.grammar.grammar._symboltable;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;

import de.monticore.generating.templateengine.reporting.Reporting;
import de.monticore.io.paths.ModelCoordinate;
import de.monticore.io.paths.ModelCoordinates;
import de.monticore.io.paths.ModelPath;
import de.monticore.modelloader.AstProvider;
import de.monticore.modelloader.IModelLoader;
import de.monticore.modelloader.ParserBasedAstProvider;
import de.monticore.utils.Names;
import de.se_rwth.commons.logging.Log;
import de.monticore.grammar.grammar._symboltable.serialization.*;

public class GrammarModelLoader implements IModelLoader<de.monticore.grammar.grammar._ast.ASTMCGrammar, IGrammarScope> {

  protected final GrammarLanguage language;

  protected AstProvider<de.monticore.grammar.grammar._ast.ASTMCGrammar> astProvider;

  public GrammarModelLoader(GrammarLanguage language) {
    this.language = language;
    this.astProvider = new ParserBasedAstProvider<>(language);
  }

  @Override
  public void createSymbolTableFromAST(final de.monticore.grammar.grammar._ast.ASTMCGrammar ast, final String modelName, final IGrammarScope enclosingScope) {
    final GrammarSymbolTableCreatorDelegator symbolTableCreator =
            getModelingLanguage().getSymbolTableCreator(enclosingScope);

    if (symbolTableCreator != null) {
      Log.debug("Start creation of symbol table for model \"" + modelName + "\".",
          de.monticore.grammar.grammar._symboltable.GrammarModelLoader.class.getSimpleName());
      final IGrammarScope scope = symbolTableCreator.createFromAST(ast);

      if (!(scope instanceof GrammarArtifactScope)) {
        Log.warn("0xA7001x420 Top scope of model " + modelName + " is expected to be an artifact scope, but"
          + " is scope \"" + scope.getName() + "\"");
      }

      Log.debug("Created symbol table for model \"" + modelName + "\".", de.monticore.grammar.grammar._symboltable.GrammarModelLoader.class.getSimpleName());
    }
    else {
      Log.warn("0xA7002x420 No symbol created, because '" + getModelingLanguage().getName()
        + "' does not define a symbol table creator.");
    }
  }

  public GrammarLanguage getModelingLanguage() {
    return this.language;
  }

  public Collection<de.monticore.grammar.grammar._ast.ASTMCGrammar> loadModelsIntoScope(final String qualifiedModelName,
      final ModelPath modelPath, IGrammarScope enclosingScope) {

    if (!loadSymbolsIntoScope(qualifiedModelName, modelPath, enclosingScope)) {
      final Collection<de.monticore.grammar.grammar._ast.ASTMCGrammar> asts = loadModels(qualifiedModelName, modelPath);
      for (de.monticore.grammar.grammar._ast.ASTMCGrammar ast : asts) {
        createSymbolTableFromAST(ast, qualifiedModelName, enclosingScope);
      }
      showWarningIfParsedModels(asts, qualifiedModelName);
      return asts;
    }
    return Collections.emptySet();
  }

  public Collection<de.monticore.grammar.grammar._ast.ASTMCGrammar> loadModels(final String qualifiedModelName, ModelPath modelPath){
    Preconditions.checkArgument(!Strings.isNullOrEmpty(qualifiedModelName));

    final Collection<de.monticore.grammar.grammar._ast.ASTMCGrammar> foundModels = new ArrayList<>();

    final ModelCoordinate resolvedCoordinate = resolve(qualifiedModelName, modelPath);
    if (resolvedCoordinate.hasLocation()) {
      final de.monticore.grammar.grammar._ast.ASTMCGrammar ast = astProvider.getRootNode(resolvedCoordinate);
      Reporting.reportOpenInputFile(Optional.of(resolvedCoordinate.getParentDirectoryPath()),
          resolvedCoordinate.getQualifiedPath());
      foundModels.add(ast);
    }

    return foundModels;
  }

  public boolean loadSymbolsIntoScope(final String qualifiedModelName,
      final ModelPath modelPath, final IGrammarScope enclosingScope)  {

    final ModelCoordinate resolvedCoordinate = resolveSymbol(qualifiedModelName, modelPath);
    if (resolvedCoordinate.hasLocation()) {
      Optional<IGrammarScope> deser  = new GrammarScopeDeSer().load(resolvedCoordinate.getLocation());
      if(deser.isPresent()) {
        enclosingScope.addSubScope(deser.get());
        return true;
      }
    }
    return false;
  }

  /**
   * @param qualifiedModelName example: "de.mc.statechartOne"
   * @return the resolved coordinate (the location of the model is set if
   * successful)
   */
  // TODO move to interface?
  private ModelCoordinate resolve(final String qualifiedModelName, final ModelPath modelPath){
    String simpleName = Names.getSimpleName(qualifiedModelName);
    Path qualifiedPath = Paths.get(
        Names.getPathFromQualifiedName(qualifiedModelName)).resolve(
        simpleName + "." + getModelingLanguage().getFileExtension());
    ModelCoordinate qualifiedModel = ModelCoordinates.createQualifiedCoordinate(qualifiedPath);

    return modelPath.resolveModel(qualifiedModel);
  }

  protected ModelCoordinate resolveSymbol(final String qualifiedModelName, final ModelPath modelPath){
    String simpleName = Names.getSimpleName(qualifiedModelName);
    Path qualifiedPath = Paths.get(
        Names.getPathFromQualifiedName(qualifiedModelName)).resolve(
        simpleName + "." + getModelingLanguage().getSymbolFileExtension());
    ModelCoordinate qualifiedModel = ModelCoordinates.createQualifiedCoordinate(qualifiedPath);

    return modelPath.resolveModel(qualifiedModel);
  }

  protected void showWarningIfParsedModels(Collection<?> asts, String modelName) {
    if(!asts.isEmpty()) {
      Log.warn("Symbol for model \""+modelName+"\" found in a model file that has not been translated yet. This works for compatibility reasons, but is deprecated and will be removed soon. Please adjust your building process.");
    }
  }

}
