# (c) https://github.com/MontiCore/monticore

#
# This makefile demonstrates how to embedd a MontiCore
# code generation and a tool execution in a
# makefile using make for efficient incremental generation
#
  # Efficient == only do what is needed; but fully automatic
  # Incremental == makefile itself checks whether to regenerate
  # and therefore uses MontiCore's IncGenCheck.sh
  #
  # It is somewhat lengthy, because it explains a lot
  #

  ##############################################    Explanations
  # The makefile handles two levels of generation and processing 
  # Level
  #   M2: MontiCore LWB generates Automata tool-code
  #        & compiles & jars it
  #   M1: The resulting Automata tool is tested
  #       and executed on real automata
  #
  # Using many default configurations, it is mainly the grammar name
  # that needs to be configured here
  # and of course the individual tool calls:
  # (then a generic part comes that can be adapted if needed)
  #

#############################################################
# M2 Configuration (files and used commands):
# Configuration A: the individual part

# M2-model to be processed (the grammar)
GRAMMAR=src/main/grammars/Automata.mc4

#############################################################
# Usage Activities (M1): processing Models:
# Each is handling one automaton (producing one file)
  #
  # Because in these executions there is no additional (optional) input
  # needed, we do not need to use an IncGenCheck for these tool executions.

$(GenSrc)-executes.f: target/PingPong.result target/HierarchyPingPong.result target/Simple12.result
        @echo "[MINFO]. 6c: Showing some results for:" $<
        @cat $@
        @echo "[MINFO]. 6c: End of results."
        @touch $@

target/PingPong.result: src/test/resources/example/PingPong.aut $(Tool)
        @echo "[MINFO]. 6a: Handling" $<
        java -cp "$(Tool);$(MCRTE)" \
             $(ToolClass) $< target/symtab/ > $@

target/HierarchyPingPong.result: src/test/resources/example/HierarchyPingPong.aut $(Tool)
        @echo "[MINFO]. 6b: Handling" $<
        java -cp "$(Tool);$(MCRTE)" \
             $(ToolClass) $< target/symtab/ > $@

target/Simple12.result: src/test/resources/example/Simple12.aut $(Tool)
        @echo "[MINFO]. 6c: Handling" $<
        java -cp "$(Tool);$(MCRTE)" \
             $(ToolClass) $< target/symtab/ > $@



#############################################################
#############################################################
# Start of generic part (which needs normally not be touched)

#############################################################
# Configuration B: the generic part

# a few things are derived from the grammar name
GramNameCap=$(patsubst src/main/grammars/%.mc4,%,$(GRAMMAR))
GramName=$(shell echo $(GramNameCap) | tr '[:upper:]' '[:lower:]')

# path for the generated sources
GenSrc=target/$(GramName)

# name of resulting tool and its main class:
Tool=target/$(GramNameCap)Tool.jar
ToolClass=$(GramName).$(GramNameCap)Tool

# M2+M1-input: All handwritten sources (from M1) for the tool
  # this is needed on M2 level to apply the TOP mechanism
SRC=$(wildcard src/**/*java)

#############################################################
# initial rule describing all relevant sub-activities

all: $(GenSrc)-tests.f  $(GenSrc)-executes.f 
	@echo "[MINFO]. Done with" $@"."

  ##############################################    Explanations
  # make normally uses real files as target of a rule,
  # sometimes dummy targets, such as "automata.f" help to 
  # to ensure that the action is atomic
  # (e.g. it may happen that the directory "automata" is created,
  # but only half of the files: the flag "automata.f" is
  # touched only if the creation was complete and successful)

#############################################################
# Generate and compile (M2):

  ##############################################    Explanations
  # The MontiCore generator has some explicitely known inputs, such as
  # the $(GRAMMAR), but the TOP mechanism adds additional implicit inputs.
  # The IncGenCheck.sh is generated by MontiCore and knows these
  # dependencies. It is included as follows:
  # goal incGenStamp.f must always be executed newly (because of
  # the force); this executes IncGenCheck.sh, which updates the
  # timestamp of incGenStamp.f if needed, which triggers a 
  # regeneration of $(GenSrc).f

$(GenSrc).incGenStamp.f: target force
	@echo "[MINFO]. 1: Check if generation for \"" $(GramName)"\" is needed"
	@[ -e $@ ] || touch $@
	@[ -e $(GenSrc)/IncGenCheck.sh ] && sh $(GenSrc)/IncGenCheck.sh $@ || true

# Activity 1 (M2): run MontiCore generator
$(GenSrc).f: $(GRAMMAR) $(MCJAR) $(MCGRAMMARS) $(GenSrc).incGenStamp.f
	@echo "[MINFO]. 1: Generation of tool code from" $(GRAMMAR)
	java -jar $(MCJAR) \
		$(GRAMMAR) \
		-mp $(MCGRAMMARS) \
		-hcp src/main/java \
		-out target
	@touch $@

  ##############################################    Explanations
  # This can be tested, e.g.
  # make
  # find . -name "ASTStateTOP*"
  #     -> finds 2 files
  # mv ./src/main/java/automata/_ast/ASTState.java xtemporary
  # make
  # find . -name "ASTStateTOP*"
  #     -> empty
  # mv xtemporary ./src/main/java/automata/_ast/ASTState.java
  # make
  # find . -name "ASTStateTOP*"
  #     -> finds again 2 files
  #

# Activity 2 (M2): compile the tool
$(GenSrc)-classes.f: $(GenSrc).f $(SRC) $(MCRTE)
	@echo "[MINFO]. 2: Compile tooli:" $(GenSrc)-classes
	@mkdir -p $(GenSrc)-classes/
	javac -cp $(MCRTE) \
	      -d $(GenSrc)-classes/ \
	      -sourcepath "target/;src/main/java/" \
	      src/main/java/$(GramName)/$(GramNameCap)Tool.java
	@touch $@

# Activity 3 (M2): build the tool jar
$(Tool): $(GenSrc)-classes.f
	@echo "[MINFO]. 3: Create tool jar:" $(Tool)
	jar cfe $(Tool) $(GramName).$(GramNameCap)Tool -C $(GenSrc)-classes .

#############################################################
# Testing (M2 and M1)

# Activity 4 (M2): compile the tests
# (which was on purpose not integrated in tool compilation)
$(GenSrc)-testclasses.f: $(Tool) $(SRC)
	@echo "[MINFO]. 4: Compile tests:" $(GenSrc)-testclasses
	@mkdir -p $(GenSrc)-testclasses/
	javac -cp "$(Tool);$(MCRTE);$(JUNIT)" \
	      -d $(GenSrc)-testclasses/ \
	      -sourcepath "target/;src/test/java/" \
	      $(wildcard src/test/java/*Test.java)
	@touch $@

# Activity 5 (M1): execute the tests
$(GenSrc)-tests.f: $(GenSrc)-testclasses.f
	@echo "[MINFO]. 5: Run tests in:" $(GenSrc)-testclasses
	@java  -cp "$(GenSrc)-testclasses;$(Tool);$(MCRTE);$(JUNIT);$(HAMCREST)" \
	       org.junit.runner.JUnitCore \
	       $(patsubst $(GenSrc)-testclasses/%.class,%,$(wildcard $(GenSrc)-testclasses/*Test.class))
	@touch $@

#############################################################
# Auxiliary

# The following simplified version does not manage updates
# of foreign libaries

# foreign jars for testing
JUNIT=target/junit-4.13.jar
HAMCREST=target/hamcrest-core-1.3.jar

# jars for the MontiCore call (M2), runtime (M1+M2), and grammars (M2)
MCJAR=target/monticore-all.jar
MCRTE=target/monticore-rt.jar
MCGRAMMARS=target/monticore-g.jar

# Initialize target directory
# (and a simplified downloading of all needed libraries at once
# and doesn't check for new snapshots):
# the MontiCore LWB; MontiCore RTE; MontiCore base grammars
# and two testing libraries
target:
	mkdir -p target
	cp ~/monticore/./monticore-cli/target/monticore-cli-*-with-dependencies.jar $(MCJAR)
	cp ~/monticore/./monticore-grammar/target/monticore-grammar-*-grammars.jar $(MCGRAMMARS)
	# TODO KH: diese kruecke ersetzen 
	#: bei mir nicht existent
	#	cp ~/monticore/./monticore-grammar/target/monticore-grammar-*-with-dependencies.jar $@
	cp ~/monticore/./monticore-cli/target/monticore-cli-*-with-dependencies.jar $(MCRTE)
	cp ~/.m2/repository/./junit/junit/4.13/junit-4.13.jar $(JUNIT)
	cp ~/.m2/repository/./org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar $(HAMCREST)

clean:
	rm -rf target

.PHONY: clean force


